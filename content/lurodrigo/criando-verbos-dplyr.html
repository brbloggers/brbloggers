<section class="page__content"> <p>Uma das decis&#xF5;es que tomei como programador R esse ano foi usar as solu&#xE7;&#xF5;es do tidyverse sempre que poss&#xED;vel, ainda que pacotes fora dele oferecessem solu&#xE7;&#xF5;es computacionalmente mais eficientes. Isso implica, naturalmente, optar pelo dplyr em vez do data.table. O motivo &#xE9; que, basicamente, percebi que os recursos computacionais maiores que o dplyr consome s&#xE3;o mais baratos que o tempo que eu levava para tentar lembrar o que os hieroglifos do data.table significavam um m&#xEA;s depois que haviam sido escritos.</p> <p>Entretanto, senti falta de algumas conveni&#xEA;ncias do data.table, em particular, a possibilidade de altera&#xE7;&#xE3;o de colunas condicional &#xE0;s linhas. Considere o seguinte exemplo: descobri que, devido a alguma falha no sistema, todos os voos registrados no dia primeiro de janeiro aconteceram, na verdade, no dia 7 de setembro. Seria bem simples corrigir isso usando data.table:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">nycflights13</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">data.table</span><span class="p">)</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data.table</span><span class="p">(</span><span class="n">flights</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; year month day dep_time sched_dep_time dep_delay arr_time
#&gt; 1: 2013 1 1 517 515 2 830
#&gt; 2: 2013 1 1 533 529 4 850
#&gt; 3: 2013 1 1 542 540 2 923
#&gt; 4: 2013 1 1 544 545 -1 1004
#&gt; 5: 2013 1 1 554 600 -6 812
#&gt; 6: 2013 1 1 554 558 -4 740
#&gt; sched_arr_time arr_delay carrier flight tailnum origin dest air_time
#&gt; 1: 819 11 UA 1545 N14228 EWR IAH 227
#&gt; 2: 830 20 UA 1714 N24211 LGA IAH 227
#&gt; 3: 850 33 AA 1141 N619AA JFK MIA 160
#&gt; 4: 1022 -18 B6 725 N804JB JFK BQN 183
#&gt; 5: 837 -25 DL 461 N668DN LGA ATL 116
#&gt; 6: 728 12 UA 1696 N39463 EWR ORD 150
#&gt; distance hour minute time_hour
#&gt; 1: 1400 5 15 2013-01-01 05:00:00
#&gt; 2: 1416 5 29 2013-01-01 05:00:00
#&gt; 3: 1089 5 40 2013-01-01 05:00:00
#&gt; 4: 1576 5 45 2013-01-01 05:00:00
#&gt; 5: 762 6 0 2013-01-01 06:00:00
#&gt; 6: 719 5 58 2013-01-01 05:00:00
</span><span class="w">
</span><span class="n">dt</span><span class="p">[</span><span class="n">month</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">`:=`</span><span class="p">(</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">7</span><span class="w">
</span><span class="p">)]</span><span class="w"> </span><span class="n">head</span><span class="p">(</span><span class="n">dt</span><span class="p">[,</span><span class="w"> </span><span class="n">.</span><span class="p">(</span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">)])</span><span class="w">
</span><span class="c1">#&gt; month day
#&gt; 1: 7 7
#&gt; 2: 7 7
#&gt; 3: 7 7
#&gt; 4: 7 7
#&gt; 5: 7 7
#&gt; 6: 7 7
</span></code></pre>
</div> <p>Infelizmente, o dplyr n&#xE3;o possui uma forma t&#xE3;o conveniente de tratar esses casos. A <a href="https://github.com/tidyverse/dplyr/issues/631">recomenda&#xE7;&#xE3;o semioficial</a> &#xE9; usar v&#xE1;rios <code class="highlighter-rouge">ifelse</code>s:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">dplyr</span><span class="p">)</span><span class="w"> </span><span class="n">flights</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">month</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">),</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">month</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">select</span><span class="p">(</span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; # A tibble: 336,776 x 2
#&gt; month day
#&gt; &lt;dbl&gt; &lt;int&gt;
#&gt; 1 7 1
#&gt; 2 7 1
#&gt; 3 7 1
#&gt; 4 7 1
#&gt; 5 7 1
#&gt; 6 7 1
#&gt; 7 7 1
#&gt; 8 7 1
#&gt; 9 7 1
#&gt; 10 7 1
#&gt; # ... with 336,766 more rows
</span></code></pre>
</div> <p>Opa! Ainda n&#xE3;o est&#xE1; correto. H&#xE1; diferen&#xE7;as sem&#xE2;nticas fortes entre o <code class="highlighter-rouge">:=</code> do data.table e o <code class="highlighter-rouge">mutate</code>. O data.table primeiro descobre em quais linhas as opera&#xE7;&#xF5;es devem ser realizadas e s&#xF3; depois as executa. O c&#xF3;digo dplyr acima n&#xE3;o: a condi&#xE7;&#xE3;o no <code class="highlighter-rouge">ifelse</code> &#xE9; reavaliada a cada coluna alterada. Al&#xE9;m disso, essas opera&#xE7;&#xF5;es s&#xE3;o feitas no escopo da tabela no estado em que estava antes da execu&#xE7;&#xE3;o de qualquer modifica&#xE7;&#xE3;o, enquanto o <code class="highlighter-rouge">mutate</code> sempre usa seu estado mais recente. &#xC9; por isso que o resultado final n&#xE3;o &#xE9; o esperado: no momento em que a linha</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">month</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">)</span><span class="w">
</span></code></pre>
</div> <p>&#xE9; executada, os valores em <code class="highlighter-rouge">month</code> j&#xE1; foram modificados para 7 (onde foi o caso), a condi&#xE7;&#xE3;o falha e os valores armazenados em <code class="highlighter-rouge">day</code> n&#xE3;o s&#xE3;o alterados. No entanto, um workaround &#xE9; poss&#xED;vel: podemos criar uma coluna tempor&#xE1;ria para armazenar o resultado da condi&#xE7;&#xE3;o do ifelse e apag&#xE1;-la depois das modifica&#xE7;&#xF5;es:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">flights</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="w"> </span><span class="n">condicao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">condicao</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">),</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">condicao</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">),</span><span class="w"> </span><span class="n">condicao</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NULL</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">select</span><span class="p">(</span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; # A tibble: 336,776 x 2
#&gt; month day
#&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 7 7
#&gt; 2 7 7
#&gt; 3 7 7
#&gt; 4 7 7
#&gt; 5 7 7
#&gt; 6 7 7
#&gt; 7 7 7
#&gt; 8 7 7
#&gt; 9 7 7
#&gt; 10 7 7
#&gt; # ... with 336,766 more rows
</span></code></pre>
</div> <p>Ok, funciona, mas ainda h&#xE1; duas inconveni&#xEA;ncias em rela&#xE7;&#xE3;o &#xE0; vers&#xE3;o data.table: primeiro, precisamos manipular diretamente uma coluna l&#xF3;gica tempor&#xE1;ria, e depois, ainda temos que repetir explicitamente o nome da coluna dentro dos <code class="highlighter-rouge">ifelse</code>s para que o valor atual seja mantido quando a condi&#xE7;&#xE3;o falhar.</p> <p>Percebi, ent&#xE3;o, que o <code class="highlighter-rouge">mutate</code> &#xE9; um verbo inconveniente nesse tipo de situa&#xE7;&#xE3;o. Felizmente, o Tidyverse lan&#xE7;ou, h&#xE1; algum tempo, o framework de <em>tidy evaluation</em> que permite, entre outras coisas, criar novos verbos para o dplyr com alguma facilidade. O objetivo desse post &#xE9; criar verbos que funcionem de forma similar &#xE0; senten&#xE7;a <code class="highlighter-rouge">dt[cond, col := val]</code> do data.table dentro do dplyr.</p> <h2 id="criando-o-verbo-transform_where">Criando o verbo <code class="highlighter-rouge">transform_where</code></h2> <p>A solu&#xE7;&#xE3;o que desenvolvi para essa situa&#xE7;&#xE3;o foi o verbo <code class="highlighter-rouge">transform_where</code>. Aqui est&#xE1; um exemplo do seu funcionamento:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">flights</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">transform_where</span><span class="p">(</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">7</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">select</span><span class="p">(</span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; # A tibble: 336,776 x 2
#&gt; month day
#&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 7 7
#&gt; 2 7 7
#&gt; 3 7 7
#&gt; 4 7 7
#&gt; 5 7 7
#&gt; 6 7 7
#&gt; 7 7 7
#&gt; 8 7 7
#&gt; 9 7 7
#&gt; 10 7 7
#&gt; # ... with 336,766 more rows
</span></code></pre>
</div> <p>T&#xE3;o compacto quanto a vers&#xE3;o data.table e ainda tem a vantagem de produzir c&#xF3;digo f&#xE1;cil de ler! E quanto c&#xF3;digo isso levou? Bem, umas dez linhas:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">rlang</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">purrr</span><span class="p">)</span><span class="w"> </span><span class="n">transform_where</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enquo</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">eval_tidy</span><span class="p">(</span><span class="n">.data</span><span class="p">)</span><span class="w"> </span><span class="n">mods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quos</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="n">mods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map2</span><span class="p">(</span><span class="n">mods</span><span class="p">,</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">mods</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="n">column_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">quo</span><span class="p">(</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">sym</span><span class="p">(</span><span class="n">column_name</span><span class="p">)))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">eval_tidy</span><span class="p">(</span><span class="n">.data</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="o">!!!</span><span class="n">mods</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div> <p>Ok, o c&#xF3;digo &#xE9; curto, mas &#xE9; cr&#xED;ptico para quem nunca teve contato com <em>non-standard evaluation</em> em geral, e com o framework de tidy evaluation em particular. Vou tentar explicar com algum detalhe como isso tudo est&#xE1; funcionando. Primeiro, os argumentos: <code class="highlighter-rouge">.data</code> representa a tabela, <code class="highlighter-rouge">condition</code> a condi&#xE7;&#xE3;o, e <code class="highlighter-rouge">...</code>, os outros argumentos, isto &#xE9;, as modifica&#xE7;&#xF5;es que devem ser realizadas.</p> <p>Vamos para a primeira linha.</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enquo</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">eval_tidy</span><span class="p">(</span><span class="n">.data</span><span class="p">)</span><span class="w">
</span></code></pre>
</div> <p><code class="highlighter-rouge">rlang::enquo</code> &#xE9; uma fun&#xE7;&#xE3;o que faz alguma magia negra para guardar, numa estrutura chamada denominada <em>quosure</em>, a <em>express&#xE3;o</em> que foi passada para <code class="highlighter-rouge">condition</code>, e n&#xE3;o seu valor. Afinal, esse valor sequer &#xE9; v&#xE1;lido ainda, pois <code class="highlighter-rouge">month == 1 &amp; day == 1</code> n&#xE3;o indica explicitamente em que tabela <code class="highlighter-rouge">month</code> e <code class="highlighter-rouge">day</code> est&#xE3;o. &#xC9; aqui que entra a fun&#xE7;&#xE3;o <code class="highlighter-rouge">rlang::eval_tidy</code>, que executa a express&#xE3;o passada a ela dentro do ambiente indicado (<code class="highlighter-rouge">.data</code>). Agora o interpretador sabe onde procurar os <code class="highlighter-rouge">month</code> e <code class="highlighter-rouge">day</code>: s&#xE3;o colunas da tabela <code class="highlighter-rouge">.data</code>, oras! Ao final dessa linha, condition guardar&#xE1; um vetor l&#xF3;gico, com <code class="highlighter-rouge">TRUE</code> nas linhas onde a condi&#xE7;&#xE3;o passou e <code class="highlighter-rouge">FALSE</code> onde falhou. Pr&#xF3;xima linha:</p> <p><code class="highlighter-rouge">rlang::quos</code> faz a mesma coisa que <code class="highlighter-rouge">enquo</code>, mas para uma lista de express&#xF5;es toda de uma vez. No caso em que essa lista tem nomes, eles tamb&#xE9;m s&#xE3;o guardados. Fa&#xE7;a o teste:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">quos</span><span class="p">(</span><span class="n">...</span><span class="p">))</span><span class="w">
</span><span class="p">}</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; [[1]]
#&gt; &lt;quosure: global&gt;
#&gt; ~a == b
#&gt;
#&gt; [[2]]
#&gt; &lt;quosure: global&gt;
#&gt; ~c + 1
#&gt;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;quosures&quot;
</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="m">3</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; $x
#&gt; &lt;quosure: global&gt;
#&gt; ~x + 2
#&gt;
#&gt; $y
#&gt; &lt;quosure: global&gt;
#&gt; ~y * 3
#&gt;
#&gt; attr(,&quot;class&quot;)
#&gt; [1] &quot;quosures&quot;
</span></code></pre>
</div> <p>A fun&#xE7;&#xE3;o a seguir &#xE9; o cora&#xE7;&#xE3;o de todo o processo. Ela transforma uma express&#xE3;o <code class="highlighter-rouge">x = expr</code> em <code class="highlighter-rouge">x = ifelse(condition, expr, x)</code>. Ou seja, ela transforma assignments simples em express&#xF5;es complexas envolvendo condi&#xE7;&#xF5;es e <code class="highlighter-rouge">ifelse</code>s, nos poupando o trabalho de digit&#xE1;-los.</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="p">(</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="n">column_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">quo</span><span class="p">(</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">sym</span><span class="p">(</span><span class="n">column_name</span><span class="p">)))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">eval_tidy</span><span class="p">(</span><span class="n">.data</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="c1">#&gt; function(quoted_expr, column_name) {
#&gt; quo(ifelse(condition, !!quoted_expr, !!sym(column_name))) %&gt;%
#&gt; eval_tidy(.data)
#&gt; }
</span></code></pre>
</div> <p>Essa fun&#xE7;&#xE3;o tem dois par&#xE2;metros: <code class="highlighter-rouge">quoted_expr</code>, uma quosure com uma express&#xE3;o capturada anteriormente, e <code class="highlighter-rouge">column_name</code>, o nome da coluna em uma string. A fun&#xE7;&#xE3;o <code class="highlighter-rouge">rlang::quo</code> salva a express&#xE3;o passada como par&#xE2;metro em uma quosure, e o operador <code class="highlighter-rouge">!!</code> faz o inverso: transforma uma quosure numa express&#xE3;o. A fun&#xE7;&#xE3;o <code class="highlighter-rouge">rlang::sym</code>, por sua vez, transforma uma string em uma express&#xE3;o (um s&#xED;mbolo, mais especificamente). Agora j&#xE1; d&#xE1; pra entender a a&#xE7;&#xE3;o da seguinte linha:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">quo</span><span class="p">(</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">sym</span><span class="p">(</span><span class="n">column_name</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div> <p>Imaginemos que <code class="highlighter-rouge">quoted_expr</code> &#xE9; uma quosure que guarda a express&#xE3;o <code class="highlighter-rouge">7</code> e <code class="highlighter-rouge">column_name</code> &#xE9; string <code class="highlighter-rouge">&quot;month&quot;</code>: ap&#xF3;s a a&#xE7;&#xE3;o do <code class="highlighter-rouge">!!</code>, a linha acima equivale a:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">quo</span><span class="p">(</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">))</span><span class="w">
</span></code></pre>
</div> <p>Essa quosure resultante &#xE9; passada para <code class="highlighter-rouge">eval_tidy</code>, que calcula o valor dessa express&#xE3;o dentro da tabela <code class="highlighter-rouge">.data</code>. No fim, a fun&#xE7;&#xE3;o retorna um vetor contendo o novo valor da coluna.</p> <p>Para quem n&#xE3;o conhece, <code class="highlighter-rouge">purrr::map2</code> &#xE9; essencialmente uma generaliza&#xE7;&#xE3;o de <code class="highlighter-rouge">lapply</code> que toma duas listas ou vetores como argumento, al&#xE9;m de uma fun&#xE7;&#xE3;o de dois par&#xE2;metros. Dados <code class="highlighter-rouge">x = c(x1, x2, x3)</code>, <code class="highlighter-rouge">y = c(y1, y2, y2)</code> e <code class="highlighter-rouge">f</code>, retorna uma lista <code class="highlighter-rouge">list(f(x1, y1), f(x2, y2), f(x3, y3))</code>. Al&#xE9;m disso, se o primeiro vetor ou lista tem <code class="highlighter-rouge">names</code>, esses <code class="highlighter-rouge">names</code> s&#xE3;o mantidos na lista resultante. Agora j&#xE1; d&#xE1; pra entender o trecho completo.</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">mods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map2</span><span class="p">(</span><span class="n">mods</span><span class="p">,</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">mods</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="n">column_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">quo</span><span class="p">(</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">sym</span><span class="p">(</span><span class="n">column_name</span><span class="p">)))</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">eval_tidy</span><span class="p">(</span><span class="n">.data</span><span class="p">)</span><span class="w">
</span><span class="p">})</span><span class="w">
</span></code></pre>
</div> <p>Pegamos <code class="highlighter-rouge">mods</code>, uma lista cujos <code class="highlighter-rouge">names</code> s&#xE3;o os nomes das colunas e cujos valores s&#xE3;o express&#xF5;es, e retornamos uma nova lista com os mesmos <code class="highlighter-rouge">names</code>, nomes das colunas, mas com as colunas j&#xE1; calculadas a partir de um <code class="highlighter-rouge">ifelse</code> adequado.</p> <p>Por &#xFA;ltimo, o operador <code class="highlighter-rouge">!!!</code> &#xE9; para <code class="highlighter-rouge">quos</code> o que <code class="highlighter-rouge">!!</code> &#xE9; para <code class="highlighter-rouge">quo</code>: transforma uma lista de quosures em uma sequ&#xEA;ncia de express&#xF5;es. Ent&#xE3;o a &#xFA;ltima linha,</p> <p>ap&#xF3;s a a&#xE7;&#xE3;o do <code class="highlighter-rouge">!!!</code>, equivale a</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">mutate</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vetorx</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vetory</span><span class="p">)</span><span class="w">
</span></code></pre>
</div> <p>onde <code class="highlighter-rouge">vetorx</code> e <code class="highlighter-rouge">vetory</code> s&#xE3;o os resultados que foram obtidos anteriormente ap&#xF3;s a execu&#xE7;&#xE3;o dos <code class="highlighter-rouge">ifelse</code>s. E pronto! Ap&#xF3;s todas essas manipula&#xE7;&#xF5;es de quosures, chegamos ao resultado que quer&#xED;amos!</p> <h2 id="criando-um-mutate_where">Criando um <code class="highlighter-rouge">mutate_where</code>:</h2> <p>Eu chamei a fun&#xE7;&#xE3;o de <code class="highlighter-rouge">transform_where</code> ao inv&#xE9;s de <code class="highlighter-rouge">mutate_where</code> em analogia &#xE0; diferen&#xE7;a entre as fun&#xE7;&#xF5;es <code class="highlighter-rouge">transform</code> e <code class="highlighter-rouge">mutate</code>: a primeira executa no contexto inicial da tabela, e a &#xFA;ltima, sempre no contexto mais recente. O exemplo abaixo esclarece a diferen&#xE7;a.</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">df</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">)</span><span class="w">
</span><span class="n">df</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; x y
#&gt; 1 2 2
#&gt; 2 3 3
#&gt; 3 4 4
#&gt; 4 5 5
#&gt; 5 6 6
</span><span class="n">df</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; x y
#&gt; 1 2 3
#&gt; 2 3 4
#&gt; 3 4 5
#&gt; 4 5 6
#&gt; 5 6 7
</span></code></pre>
</div> <p>Eu criei um <code class="highlighter-rouge">transform_where</code> porque parecia atender melhor minhas necessidades, mas &#xE9; poss&#xED;vel conceber situa&#xE7;&#xF5;es onde um <code class="highlighter-rouge">mutate_where</code> fosse mais conveniente. &#xC9; muito mais dif&#xED;cil fazer isso? N&#xE3;o. Eis o c&#xF3;digo:</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">mutate_where</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enquo</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">eval_tidy</span><span class="p">(</span><span class="n">.data</span><span class="p">)</span><span class="w"> </span><span class="n">mods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quos</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="n">mods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map2</span><span class="p">(</span><span class="n">mods</span><span class="p">,</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">mods</span><span class="p">),</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="n">column_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">quo</span><span class="p">(</span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">quoted_expr</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">sym</span><span class="p">(</span><span class="n">column_name</span><span class="p">)))</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="o">!!!</span><span class="n">mods</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div> <p>Ele &#xE9; <em>quase</em> igual ao c&#xF3;digo do <code class="highlighter-rouge">transform_where</code>, com uma pequena diferen&#xE7;a: n&#xE3;o h&#xE1; um <code class="highlighter-rouge">eval_tidy</code> dentro da fun&#xE7;&#xE3;o auxiliar. Isso faz com que, ao inv&#xE9;s de se calcular logo o valor das colunas modificadas, apenas se substitua as express&#xF5;es passadas por express&#xF5;es envoltas por um <code class="highlighter-rouge">ifelse</code>. Ao contr&#xE1;rio de antes, a linha</p> <p>n&#xE3;o vira</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">mutate</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vetorx</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vetory</span><span class="p">)</span><span class="w">
</span></code></pre>
</div> <p>e sim</p> <div class="language-r highlighter-rouge"><pre class="highlight"><code><span class="n">mutate</span><span class="p">(</span><span class="n">.data</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ifelse</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w">
</span></code></pre>
</div> <p>ent&#xE3;o essas modifica&#xE7;&#xF5;es s&#xE3;o executadas com a sem&#xE2;ntica tradicional do dplyr, isto &#xE9;, usando eventualmente os valores modificados que acabaram de ser computados, em vez dos valores guardados antes da execu&#xE7;&#xE3;o da fun&#xE7;&#xE3;o.</p> <p>Qual a melhor das duas fun&#xE7;&#xF5;es? Depende do contexto. No caso que abriu o post, certamente um <code class="highlighter-rouge">transform_where</code> funciona melhor. Agora imagine uma situa&#xE7;&#xE3;o onde os dados de partida e chegada estivessem incorretos em algumas linhas. A vari&#xE1;vel <code class="highlighter-rouge">air_time</code>, tempo de voo, tamb&#xE9;m precisar&#xE1; ser atualizada. Nesse caso, um <code class="highlighter-rouge">mutate_where</code> corrigindo os valores de <code class="highlighter-rouge">dep_time</code> e <code class="highlighter-rouge">arr_time</code> e recalculando <code class="highlighter-rouge">air_time</code> como essa diferen&#xE7;a resolver&#xE1; a situa&#xE7;&#xE3;o, enquanto um <code class="highlighter-rouge">transform_where</code>, iria, de fato, manter a coluna <code class="highlighter-rouge">air_time</code> como estava antes. Na pr&#xE1;tica, sempre tenho as duas em m&#xE3;os.</p> <p><strong>Exerc&#xED;cio para o leitor:</strong> Uma diferen&#xE7;a entre o meu <code class="highlighter-rouge">transform_where</code> e o funcionamento do <code class="highlighter-rouge">data.table</code> &#xE9; que esse &#xFA;ltimo consegue criar colunas novas, preenchendo-as com <code class="highlighter-rouge">NA</code> nas linhas onde a condi&#xE7;&#xE3;o &#xE9; falsa. Sinceramente, esse comportamento me desagrada, por implicar que a tabela poder&#xE1; sair com formatos diferentes dependendo de uma condi&#xE7;&#xE3;o de forma nada expl&#xED;cita. De todo modo, como poder&#xED;amos modificar <code class="highlighter-rouge">transform_where</code> para que ela tenha esse comportamento?</p> </section>
