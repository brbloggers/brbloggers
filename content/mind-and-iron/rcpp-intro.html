<div class="entry-content"> <p>O que fazer quando precisamos que o nosso script rode mais r&#xE1;pido? Geralmente a primeira ideia que temos &#xE9; otimizar o c&#xF3;digo: reduzir a quantidade de la&#xE7;os, diminuir o tamanho das estruturas, utilizar programa&#xE7;&#xE3;o paralela, etc&#x2026; Mas quando se trata de R, temos a possibilidade de aumentar a velocidade do c&#xF3;digo sem alterar praticamente nada da sua estrutura.</p>
<p>Neste post darei uma introdu&#xE7;&#xE3;o b&#xE1;sica ao pacote <code>Rcpp</code>, uma ferramenta que nos permite rodar c&#xF3;digo em C++ de dentro do R.</p>
<div id="o-basico" class="section level2"> <p>C++ &#xE9; uma linguagem de programa&#xE7;&#xE3;o muito famosa e vers&#xE1;til. Ela t&#xEA;m elementos de programa&#xE7;&#xE3;o gen&#xE9;rica, imperativa e orientada a objeto e tamb&#xE9;m fornece uma interface para manipula&#xE7;&#xE3;o de mem&#xF3;ria de baixo n&#xED;vel.</p>
<p>Uma caracter&#xED;stica interessante do C++ &#xE9; que ele &#xE9; <em>extremamente</em> veloz. Diferentemente do R, ela &#xE9; uma linguagem compilada, com tipagem est&#xE1;tica e que n&#xE3;o fornece tantas abstra&#xE7;&#xF5;es de opera&#xE7;&#xF5;es, permitindo que seu c&#xF3;digo execute com efici&#xEA;ncia incr&#xED;vel.</p>
<p>Para explorar os benef&#xED;cios que o C++ pode trazer para o seu c&#xF3;digo R, instale e carregue o pacote <code>Rcpp</code> com os comandos abaixo:</p>
<pre class="r"><code>install.packages(&quot;Rcpp&quot;)
library(Rcpp)</code></pre>
<p>Vejamos agora um exemplo simples de como chamar c&#xF3;digo C++ do R. O jeito mais f&#xE1;cil de fazer isso &#xE9; atrav&#xE9;s da fun&#xE7;&#xE3;o <code>cppFunction()</code>: ela recebe uma string que ser&#xE1; interpretada como uma fun&#xE7;&#xE3;o em C++.</p>
<pre class="r"><code>adicao_r &lt;- function(x, y, z) { sum = x + y + z return(sum)
} cppFunction( &quot;int adicao_c(int x, int y, int z) { int sum = x + y + z; return sum; }&quot;) adicao_r(1, 2, 3)
#&gt; [1] 6 adicao_c(1, 2, 3)
#&gt; [1] 6</code></pre>
<p>Como podemos observar no exemplo acima, ambas as fun&#xE7;&#xF5;es t&#xEA;m o mesmo comportamento apesar de algumas diferen&#xE7;as superficiais. Note como temos sempre que declarar os tipos das vari&#xE1;veis em C++! Usando a palavra-chave <code>int</code> deixamos claro para o compilador que uma vari&#xE1;vel ter&#xE1; o tipo inteiro e at&#xE9; mesmo que uma fun&#xE7;&#xE3;o deve retornar um valor de tipo inteiro. Outra coisa que &#xE9; importante lembrar &#xE9; que precisamos colocar um ponto-e-v&#xED;rgula ap&#xF3;s cada comando C++.</p>
</div>
<div id="vetores" class="section level2"> <p>Normalmente o C++ teria diferen&#xE7;as enormes em rela&#xE7;&#xE3;o ao R no seu tratamento de vetores, mas para a nossa sorte o <code>Rcpp</code> nos disponibiliza uma biblioteca de estruturas que abstraem o comportamento do R. No exemplo a seguir temos uma fun&#xE7;&#xE3;o que recebe um n&#xFA;mero e vetor num&#xE9;rico, computa a dist&#xE2;ncia euclidiana entre o valor e o vetor e retorna um vetor num&#xE9;rico como sa&#xED;da.</p>
<pre class="r"><code>dist_r &lt;- function(x, ys) { sqrt((x - ys) ^ 2)
} cppFunction( &quot;NumericVector dist_c(double x, NumericVector ys) { int n = ys.size(); NumericVector out(n); for(int i = 0; i &lt; n; i++) { out[i] = sqrt(pow(ys[i] - x, 2.0)); } return out; }&quot;) dist_r(10, 20:25)
#&gt; [1] 10 11 12 13 14 15 dist_c(10, 20:25)
#&gt; [1] 10 11 12 13 14 15</code></pre>
<p>A estrutura <code>NumericVector</code> abstrai um vetor num&#xE9;rico do R, nos permitindo trabalhar com ele de uma maneira mais familiar. Com o m&#xE9;todo <code>.size()</code> obtemos o seu comprimento (equivalente a <code>length()</code>) e podemos declarar um novo com o construtor <code>NumericVector nome(comprimento);</code>. O &#xFA;nico ponto de diferen&#xE7;a fundamental entre o C++ e o R &#xE9; que o primeiro n&#xE3;o possui opera&#xE7;&#xF5;es vetorizadas propriamente ditas, fazendo com que precisemos usar la&#xE7;os para toda e qualquer itera&#xE7;&#xE3;o.</p>
</div>
<div id="velocidade-maxima" class="section level2"> <p>Certos aspectos da filosofia do R o tornam uma linguagem extremamente vers&#xE1;til, mas isso vem com certas desvantagens. Alguns pontos em que a performance do R deixa a desejar s&#xE3;o la&#xE7;o n&#xE3;o vetoriz&#xE1;veis (por uma itera&#xE7;&#xE3;o depender da anterior), fun&#xE7;&#xF5;es recursivas e estruturas de dados complexas.</p>
<p>Nestas e em muitas outras situa&#xE7;&#xF5;es, usar C++ pode ser extremamente vantajoso. No exemplo a seguir veremos a diferen&#xE7;a entre a performance de um la&#xE7;o em C++ e um em R; note que esta nem &#xE9; uma das 3 situa&#xE7;&#xF5;es listadas no par&#xE1;grafo anterior e que mesmo assim o c&#xF3;digo em C++ &#xE9; <em>6 vezes mais r&#xE1;pido</em>.</p>
<pre class="r"><code>soma_r &lt;- function(v) { total &lt;- 0 for (e in v) { if (e &lt; 0) { total = total - e } else if (e &gt; 0.75) { total = total + e/2 } else { total = total + e } } return(total)
} cppFunction( &quot;double soma_c(NumericVector v) { double total = 0; for (int i = 0; i &lt; v.size(); i++) { if (v[i] &lt; 0) { total -= v[i]; } else if (v[i] &gt; 0.75) { total += v[i]/2; } else { total += v[i]; } } return(total); }&quot;) v &lt;- runif(100000, -1, 1)
microbenchmark::microbenchmark(soma_r(v), soma_c(v))
#&gt; Unit: milliseconds
#&gt; expr min lq mean median uq max neval
#&gt; soma_r(v) 6.105048 6.436608 6.911819 6.718456 7.183266 11.610624 100
#&gt; soma_c(v) 1.045805 1.063956 1.161585 1.097920 1.210052 1.955702 100</code></pre>
<p><strong>Obs.</strong>: Os s&#xED;mbolos <code>+=</code> e <code>-=</code> s&#xE3;o equivalentes a <code>a = a +/- b</code>, j&#xE1; o s&#xED;mbolo <code>++</code> &#xE9; equivalente a <code>a = a + 1</code>.</p>
</div>
<div id="conclusao" class="section level2"> <p>Com o pacote <code>Rcpp</code>, podemos rodar c&#xF3;digo em C++ de dentro do pr&#xF3;prio R. Atrav&#xE9;s dessa t&#xE9;cnica conseguimos otimizar nosso c&#xF3;digo ou mesmo ter acesso a estruturas de dados complexas disponibilizadas pelo C++.</p>
<p>Para saber mais sobre o assunto, d&#xEA; uma olhada no <a href="http://adv-r.had.co.nz/Rcpp.html">tutorial</a> escrito por Hadley Wickham no livro <em>Advanced R</em>. Tamb&#xE9;m recomendo a pr&#xF3;pria <a href="http://www.rcpp.org/">p&#xE1;gina</a> do <code>Rcpp</code> e sua extensa <a href="http://gallery.rcpp.org/">galeria de exemplos</a>.</p>
<p>P.S.: Se voc&#xEA; quiser o c&#xF3;digo completo deste tutorial, disponibilizei ele em um <a href="https://gist.github.com/ctlente/8d6c025a8e60319fdba63f247cef164a">Gist</a>.</p>
</div> </div>
